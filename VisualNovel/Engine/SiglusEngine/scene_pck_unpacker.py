import argparse
import datetime
import struct
from dataclasses import dataclass
from pathlib import Path, PureWindowsPath
from typing import List, Sequence, Tuple


def parse_args(argv: Sequence[str] | None = None) -> argparse.Namespace:
    parser = argparse.ArgumentParser()
    parser.add_argument("pack", type=Path, help="Path to Scene.pck")
    parser.add_argument("-o", "--output", type=Path, default=Path("."))
    return parser.parse_args(argv)


# fmt:off
EASY_ANGOU_CODE = bytes([
    0xA9, 0x19, 0x0F, 0x28, 0x2D, 0x1B, 0x52, 0x39, 0x5C, 0x36, 0x22, 0x9F, 0x91, 0x73, 0x6A, 0x35,
    0x67, 0x6A, 0x6F, 0x74, 0xEC, 0x7A, 0x6F, 0x26, 0x74, 0x0E, 0xDB, 0x27, 0x4C, 0xA5, 0xF1, 0x0E,
    0x2D, 0x70, 0xC4, 0x40, 0x5D, 0x4F, 0xDA, 0x9E, 0xC5, 0x49, 0x7B, 0xBD, 0xE8, 0xDF, 0xEE, 0xCA,
    0xF4, 0x92, 0xDE, 0xE4, 0x76, 0x10, 0xDD, 0x2A, 0x52, 0xDC, 0x73, 0x4E, 0x54, 0x8C, 0x30, 0x3D,
    0x9A, 0xB2, 0x9B, 0xB8, 0x93, 0x29, 0x55, 0xFA, 0x7A, 0xC9, 0xDA, 0x10, 0x97, 0xE5, 0xB6, 0x23,
    0x02, 0xDD, 0x38, 0x4C, 0x2C, 0xC4, 0x2D, 0x7F, 0x9B, 0x1F, 0x9A, 0xD5, 0x49, 0xE9, 0x34, 0x89,
    0x56, 0xA7, 0x96, 0x14, 0xBE, 0x2E, 0xC5, 0xB1, 0x7E, 0xD1, 0xB5, 0xE7, 0xE6, 0xD5, 0xF5, 0x06,
    0xD6, 0xBA, 0xBF, 0xF3, 0x45, 0x3F, 0xF1, 0x61, 0xDD, 0x4C, 0x3E, 0x08, 0x5F, 0x47, 0xA9, 0xDF,
    0x88, 0x9F, 0xD4, 0xCC, 0x69, 0x1F, 0x30, 0x9F, 0xE7, 0xCD, 0x80, 0x45, 0xF3, 0xE7, 0x2A, 0x1D,
    0x16, 0xB2, 0xF1, 0x54, 0xC8, 0x6C, 0x2B, 0x0D, 0xD4, 0x65, 0xF7, 0xE3, 0x36, 0xD4, 0xA5, 0x3B,
    0xD1, 0x79, 0x4C, 0x54, 0xF0, 0x2A, 0xB4, 0xB2, 0x56, 0x45, 0x2E, 0xAB, 0x7B, 0x88, 0xC5, 0xFA,
    0x74, 0xAD, 0x03, 0xB8, 0x9E, 0xD5, 0xF5, 0x6F, 0xDC, 0xFA, 0x44, 0x22, 0xAA, 0xD8, 0x29, 0xB9,
    0x16, 0x3D, 0x1A, 0x76, 0xD0, 0x87, 0x9B, 0x2D, 0x0C, 0x7B, 0xD1, 0xE1, 0xAD, 0xA9, 0x19, 0x0F,
    0x28, 0x2D, 0x1B, 0x52, 0x39, 0x5C, 0x36, 0x22, 0x9F, 0x49, 0x31, 0xF6, 0x83, 0x32, 0xFF, 0xC2,
    0xB1, 0xE9, 0xE1, 0x98, 0x3D, 0x6F, 0x31, 0x0D, 0xAC, 0xB1, 0x08, 0x83, 0x9D, 0x0D, 0x10, 0xD1,
    0x41, 0xF9, 0x00, 0xBA, 0x1A, 0xCF, 0x13, 0x71, 0xE4, 0x86, 0x21, 0x2F, 0x23, 0x65, 0xC3, 0x45,
])

MASK_ANGOU_CODE = bytes([
    0x6A, 0x35, 0xB1, 0x7E, 0xD1, 0xB5, 0xE7, 0xE6, 0xD5, 0xA9, 0x19, 0x0F, 0x28, 0x2D, 0xF4, 0xC3,
    0x92, 0x48, 0x9D, 0xEA, 0xDD, 0x31, 0x2C, 0xE9, 0xE2, 0x10, 0x91, 0x73, 0x4C, 0x3E, 0x08, 0x5F,
    0x47, 0xA9, 0xDF, 0x88, 0x9F, 0xD4, 0xCC, 0x69, 0x1F, 0x30, 0x9F, 0xE7, 0xCD, 0x80, 0x45, 0xF3,
    0xE7, 0x2A, 0x1D, 0x16, 0xB2, 0xF1, 0x6A, 0x35, 0x67, 0x6A, 0x6F, 0x74, 0xEC, 0x7A, 0x6F, 0x26,
    0x74, 0x92, 0xDE, 0xE4, 0x76, 0x10, 0xDD, 0x2A, 0x52, 0xDC, 0x73, 0x4E, 0x54, 0x8C, 0x30, 0x3D,
    0x9A, 0xB2, 0x9B, 0xB8, 0x93, 0x29, 0x55, 0xFA, 0x7A, 0xC9, 0xDA, 0x10, 0x97, 0xE5, 0xB6, 0x23,
    0x02, 0xDD, 0x38, 0x4C, 0x2C, 0xC4, 0x2D, 0x39, 0x5C, 0x36, 0x22, 0x9F, 0x91, 0x73, 0xF5, 0x06,
    0xD6, 0xBA, 0xBF, 0xF3, 0x45, 0x3F, 0xF1, 0x61, 0xDD, 0x4C, 0x7F, 0x9B, 0x1F, 0x9A, 0xD5, 0x49,
    0xE9, 0x34, 0x89, 0x56, 0xA7, 0x96, 0x14, 0xBE, 0x2E, 0xC5, 0x3E, 0x08, 0x5F, 0x47, 0xA9, 0xDF,
    0x88, 0x9F, 0xD4, 0xCC, 0x69, 0x1F, 0x30, 0x9F, 0xE7, 0xCD, 0x80, 0x45, 0xF3, 0xE7, 0x2A, 0x1D,
    0x16, 0xB2, 0xF1, 0x54, 0xC8, 0x6C, 0x2B, 0x0D, 0xD4, 0x65, 0xF7, 0xE3, 0x36, 0xD4, 0xA5, 0x3B,
    0xD1, 0x79, 0x4C, 0x54, 0xF0, 0x2A, 0xB4, 0xB2, 0x56, 0x45, 0x2E, 0xCA, 0xF4, 0x92, 0xDE, 0xE4,
    0x76, 0x10, 0xDD, 0x2A, 0x52, 0xDC, 0x73, 0x4E, 0x54, 0x8C, 0x30, 0x3D, 0x9A, 0xB2, 0x9B, 0xB8,
    0x93, 0x29, 0x55, 0xFA, 0x7A, 0xC9, 0xDA, 0x10, 0x97, 0xAB, 0x23, 0x65, 0xC3, 0x45, 0xA0, 0xC3,
    0x92, 0x48, 0x9D, 0xEA, 0xDD, 0x31, 0x2C, 0xE9, 0xE2, 0x10, 0x7B, 0x88, 0xC5, 0xFA, 0x74, 0xAD,
    0x03, 0xB8, 0x9E, 0xD5, 0xF5, 0x6F, 0xDC, 0xFA, 0x44, 0x49, 0x31, 0xF6, 0x83, 0x32, 0xFF, 0xC2,
])

LAST_ANGOU_CODE = bytes([
    0x0E, 0xDB, 0x27, 0x4C, 0xA5, 0xF1, 0x0E, 0x2D, 0x70, 0xC4, 0x40, 0x5D, 0x4F, 0xDA, 0xA0, 0xC3,
    0x92, 0x48, 0x9D, 0xEA, 0xDD, 0x31, 0x2C, 0xE9, 0xE2, 0x10, 0x22, 0xAA, 0xD8, 0x29, 0xB9, 0x16,
    0x3D, 0x1A, 0x76, 0xD0, 0x87, 0x9B, 0x2D, 0x0C, 0x7B, 0xD1, 0xE1, 0xAD, 0x9E, 0xC5, 0x49, 0x7B,
    0xBD, 0xE8, 0xDF, 0xEE, 0xCA, 0xF4, 0x92, 0xDE, 0xE4, 0x76, 0x10, 0xDD, 0x2A, 0x52, 0xDC, 0x73,
    0x4E, 0x54, 0x8C, 0x30, 0x3D, 0x9A, 0xB2, 0x9B, 0xB8, 0x93, 0x29, 0x55, 0xFA, 0x7A, 0xC9, 0xDA,
    0x10, 0x97, 0xE5, 0xB6, 0x23, 0x02, 0xDD, 0x38, 0x4C, 0x2C, 0xC4, 0x2D, 0x7F, 0x9B, 0x1F, 0x9A,
    0xD5, 0x49, 0xE9, 0x34, 0x89, 0x56, 0xA7, 0x96, 0x14, 0xBE, 0x2E, 0xC5, 0xB1, 0x7E, 0xD1, 0xB5,
    0xE7, 0xE6, 0xD5, 0xF5, 0x06, 0xD6, 0xBA, 0xBF, 0xF3, 0x45, 0x3F, 0xF1, 0x61, 0xDD, 0x54, 0xC8,
    0x2E, 0xAB, 0x7B, 0x88, 0xC5, 0xFA, 0x74, 0xAD, 0x03, 0xB8, 0x9E, 0xD5, 0xF5, 0x6F, 0x6C, 0x2B,
    0x0D, 0xD4, 0x65, 0xF7, 0xE3, 0x36, 0xD4, 0xA5, 0x3B, 0xD1, 0x79, 0x4C, 0x54, 0xF0, 0x2A, 0xB4,
    0xB2, 0x56, 0x45, 0xDC, 0xFA, 0x44, 0x49, 0x31, 0xF6, 0x83, 0x32, 0xFF, 0xC2, 0xB1, 0xE9, 0xE1,
    0x98, 0x3D, 0x6F, 0x31, 0x0D, 0xAC, 0xB1, 0x08, 0x83, 0x9D, 0x0D, 0x10, 0xD1, 0x41, 0xF9, 0x00,
    0xBA, 0x1A, 0xCF, 0x13, 0x71, 0xE4, 0x86, 0x21, 0x2F, 0x23, 0x65, 0xC3, 0x45, 0xA0, 0x1B, 0x52,
    0x67, 0x6A, 0x6F, 0x74, 0xEC, 0x7A, 0x6F, 0x26, 0x74, 0x0E, 0xDB, 0x27, 0x4C, 0xA5, 0xF1, 0x0E,
    0x2D, 0x70, 0xC4, 0x40, 0x5D, 0x4F, 0xDA, 0x9E, 0xC5, 0x49, 0x7B, 0xBD, 0xE8, 0xDF, 0xD8, 0x29,
    0xB9, 0x16, 0x3D, 0x1A, 0x76, 0xD0, 0x87, 0x9B, 0x2D, 0x0C, 0x7B, 0xD1, 0xE1, 0xAD, 0xEE, 0xCA,
])

NAME_ANGOU_CODE = bytes([
    0x28, 0x2D, 0x91, 0x73, 0xF5, 0x06, 0xD6, 0xBA, 0xBF, 0xF3, 0x45, 0x3F, 0xF1, 0x61, 0xB1, 0xE9,
    0xE1, 0x98, 0x3D, 0x6F, 0x31, 0x0D, 0xAC, 0xB1, 0x08, 0x83, 0x9D, 0x0D, 0x10, 0xD1, 0x41, 0xF9,
    0x00, 0xBA, 0x1A, 0xCF, 0x13, 0x71, 0xE4, 0x86, 0x21, 0x2F, 0x22, 0xAA, 0xDD, 0x4C, 0x7F, 0x9B,
    0x1F, 0x9A, 0xD5, 0x49, 0xE9, 0x34, 0x89, 0x56, 0xA7, 0x96, 0x1B, 0x52, 0x67, 0x6A, 0x6F, 0x74,
    0xCD, 0x80, 0x45, 0xF3, 0xE7, 0x2A, 0x1D, 0x16, 0xB2, 0xF1, 0x54, 0xC8, 0x6C, 0x2B, 0x0D, 0xD4,
    0x65, 0xF7, 0xE3, 0x36, 0xD4, 0xA5, 0x3B, 0xD1, 0x79, 0x4C, 0x54, 0xF0, 0x2A, 0xB4, 0xB2, 0x56,
    0x45, 0x2E, 0xAB, 0x23, 0x65, 0xC3, 0x45, 0xA0, 0xC3, 0x92, 0x48, 0x9D, 0xEA, 0xDD, 0x31, 0x2C,
    0xE9, 0xE2, 0x10, 0x7B, 0x88, 0xC5, 0xFA, 0x74, 0xAD, 0x03, 0xB8, 0x9E, 0xD5, 0xF5, 0x6F, 0xDC,
    0xFA, 0x44, 0x49, 0x31, 0xF6, 0x83, 0x32, 0xFF, 0xC2, 0xB1, 0xE9, 0xE1, 0x98, 0x3D, 0x6F, 0x31,
    0x0D, 0xAC, 0xB1, 0x08, 0x83, 0x9D, 0x0D, 0x10, 0xD1, 0x41, 0xF9, 0x00, 0xBA, 0x1A, 0xCF, 0x13,
    0x71, 0xE4, 0x86, 0x21, 0x2F, 0x22, 0xAA, 0x6A, 0x35, 0xB1, 0x7E, 0xD1, 0xB5, 0xE7, 0xEC, 0x7A,
    0x6F, 0x26, 0x74, 0x0E, 0xDB, 0x27, 0x4C, 0xA5, 0xF1, 0x0E, 0x2D, 0x70, 0xC4, 0x40, 0x5D, 0x4F,
    0xDA, 0x9E, 0xC5, 0x49, 0x7B, 0xBD, 0xE8, 0xDF, 0xD8, 0x29, 0xB9, 0x16, 0x3D, 0x1A, 0xBA, 0xBF,
    0xDF, 0xD8, 0x29, 0xB9, 0x16, 0x3D, 0x1A, 0x76, 0xD0, 0x87, 0x9B, 0x2D, 0x0C, 0x7B, 0xD1, 0xE1,
    0xAD, 0xEE, 0xCA, 0xF4, 0x92, 0xDE, 0xE4, 0x76, 0x10, 0xDD, 0x2A, 0x52, 0xDC, 0x73, 0x4E, 0x54,
    0x8C, 0x30, 0x3D, 0x9A, 0xB2, 0x9B, 0xB8, 0x93, 0x29, 0x55, 0xFA, 0x7A, 0xC9, 0xDA, 0x10, 0x97,
])
# fmt:on
EASY_ANGOU_CODE_SIZE = len(EASY_ANGOU_CODE)
MASK_ANGOU_CODE_SIZE = len(MASK_ANGOU_CODE)
LAST_ANGOU_CODE_SIZE = len(LAST_ANGOU_CODE)
NAME_ANGOU_CODE_SIZE = len(NAME_ANGOU_CODE)
MD5_CODE_CNT = 16

EASY_ANGOU_INDEX = 173
MASK_ANGOU_INDEX = 96
LAST_ANGOU_INDEX = 13
NAME_ANGOU_INDEX = 59

MASK_MD5_INDEX = 11

MASK_W_SIZE_MD5_CODE_INDEX = 5
MASK_W_SIZE_SURPLUS = 16
MASK_W_SIZE_ADD = 16
MASK_H_SIZE_MD5_CODE_INDEX = 8
MASK_H_SIZE_SURPLUS = 16
MASK_H_SIZE_ADD = 16

MAP_W_SIZE_MD5_CODE_INDEX = 9
MAP_W_SIZE_SURPLUS = 32
MAP_W_SIZE_ADD = 32

TILE_COPY_T_REP_X = 111
TILE_COPY_T_REP_Y = 37
TILE_COPY_T_LIMIT = 128

LZSS_INDEX_BIT_COUNT = 12
LZSS_BREAK_EVEN = 1
LZSS_LENGTH_BIT_COUNT = 16 - LZSS_INDEX_BIT_COUNT
LZSS_LENGTH_AND = (1 << LZSS_LENGTH_BIT_COUNT) - 1

PACK_HEADER_FIELDS: Tuple[str, ...] = (
    "header_size",
    "inc_prop_list_ofs",
    "inc_prop_cnt",
    "inc_prop_name_index_list_ofs",
    "inc_prop_name_index_cnt",
    "inc_prop_name_list_ofs",
    "inc_prop_name_cnt",
    "inc_cmd_list_ofs",
    "inc_cmd_cnt",
    "inc_cmd_name_index_list_ofs",
    "inc_cmd_name_index_cnt",
    "inc_cmd_name_list_ofs",
    "inc_cmd_name_cnt",
    "scn_name_index_list_ofs",
    "scn_name_index_cnt",
    "scn_name_list_ofs",
    "scn_name_cnt",
    "scn_data_index_list_ofs",
    "scn_data_index_cnt",
    "scn_data_list_ofs",
    "scn_data_cnt",
    "scn_data_exe_angou_mod",
    "original_source_header_size",
)

PACK_HEADER_STRUCT = struct.Struct("<" + "i" * len(PACK_HEADER_FIELDS))
C_INDEX_STRUCT = struct.Struct("<ii")
STNS_HEADER_STRUCT = struct.Struct("<" + "i" * (1 + MD5_CODE_CNT + 1))


@dataclass(frozen=True)
class PackHeader:
    header_size: int
    inc_prop_list_ofs: int
    inc_prop_cnt: int
    inc_prop_name_index_list_ofs: int
    inc_prop_name_index_cnt: int
    inc_prop_name_list_ofs: int
    inc_prop_name_cnt: int
    inc_cmd_list_ofs: int
    inc_cmd_cnt: int
    inc_cmd_name_index_list_ofs: int
    inc_cmd_name_index_cnt: int
    inc_cmd_name_list_ofs: int
    inc_cmd_name_cnt: int
    scn_name_index_list_ofs: int
    scn_name_index_cnt: int
    scn_name_list_ofs: int
    scn_name_cnt: int
    scn_data_index_list_ofs: int
    scn_data_index_cnt: int
    scn_data_list_ofs: int
    scn_data_cnt: int
    scn_data_exe_angou_mod: int
    original_source_header_size: int


@dataclass
class DecryptedEntry:
    name: str
    data: bytes


def to_pack_header(buf: bytes) -> PackHeader:
    if len(buf) < PACK_HEADER_STRUCT.size:
        raise ValueError("pack file too small to contain header")
    values = PACK_HEADER_STRUCT.unpack_from(buf, 0)
    return PackHeader(**dict(zip(PACK_HEADER_FIELDS, values)))


def c_int_mod(value: int, modulus: int) -> int:
    if modulus <= 0:
        raise ValueError("modulus must be positive")
    if value >= 0:
        return value % modulus
    return -((-value) % modulus)


def xor_stream(target: bytearray, key: bytes, start_index: int) -> None:
    if not target or not key:
        return
    key_len = len(key)
    idx = start_index % key_len
    for i in range(len(target)):
        target[i] ^= key[idx]
        idx += 1
        if idx == key_len:
            idx = 0


def build_mask(md5_code: Sequence[int], total_size: int) -> bytearray:
    mask = bytearray(total_size)
    ind = MASK_ANGOU_INDEX
    md5_ind = MASK_MD5_INDEX
    for i in range(total_size):
        mask[i] = (MASK_ANGOU_CODE[ind] ^ (md5_code[md5_ind] & 0xFF)) & 0xFF
        ind += 1
        if ind == MASK_ANGOU_CODE_SIZE:
            ind = 0
        md5_ind += 1
        if md5_ind == MD5_CODE_CNT:
            md5_ind = 0
    return mask


def tile_copy(dst: bytearray, src_view: memoryview, buf_xl: int, buf_yl: int, tile: Sequence[int], t_xl: int, t_yl: int, t_repx: int, t_repy: int, t_reverse: int, t_limit_byte: int) -> None:
    if not dst or not src_view:
        return
    expected_bytes = buf_xl * buf_yl * 4
    if len(dst) < expected_bytes or len(src_view) < expected_bytes:
        raise ValueError("buffer sizes do not match tile dimensions")
    tile_total = t_xl * t_yl
    if len(tile) < tile_total:
        raise ValueError("tile buffer too small")

    if t_repx <= 0:
        t_x = c_int_mod(-t_repx, t_xl)
    else:
        t_x = c_int_mod(t_xl - c_int_mod(t_repx, t_xl), t_xl)
    if t_repy <= 0:
        t_y = c_int_mod(-t_repy, t_yl)
    else:
        t_y = c_int_mod(t_yl - c_int_mod(t_repy, t_yl), t_yl)

    t_adr = t_y * t_xl
    t_limit = t_limit_byte & 0xFF
    dest_index = 0
    src_index = 0

    for _ in range(buf_yl):
        tile_x = t_x
        for _ in range(buf_xl):
            tile_byte = tile[t_adr + tile_x]
            copy_flag = (tile_byte >= t_limit) if t_reverse == 0 else (tile_byte < t_limit)
            if copy_flag:
                dst[dest_index : dest_index + 4] = src_view[src_index : src_index + 4]
            dest_index += 4
            src_index += 4
            tile_x += 1
            if tile_x == t_xl:
                tile_x = 0

        t_adr += t_xl
        if t_adr >= tile_total:
            t_adr = 0


def lzss_unpack(data: bytes) -> bytes:
    if len(data) < 8:
        raise ValueError("lzss stream too short")
    _, org_size = struct.unpack_from("<II", data, 0)
    if org_size == 0:
        return b""

    result = bytearray(org_size)
    src_idx = 8
    dst_idx = 0
    data_len = len(data)

    while dst_idx < org_size:
        if src_idx >= data_len:
            raise ValueError("unexpected end of data reading flags")
        flags = data[src_idx]
        src_idx += 1

        for _ in range(8):
            if dst_idx >= org_size:
                break

            if flags & 0x01:
                if src_idx >= data_len:
                    raise ValueError("unexpected end of data reading literal")
                result[dst_idx] = data[src_idx]
                dst_idx += 1
                src_idx += 1
            else:
                if src_idx + 1 >= data_len:
                    raise ValueError("unexpected end of data reading reference")
                word = data[src_idx] | (data[src_idx + 1] << 8)
                src_idx += 2
                offset = word >> LZSS_LENGTH_BIT_COUNT
                length = (word & LZSS_LENGTH_AND) + (LZSS_BREAK_EVEN + 1)

                src_pos = dst_idx - offset
                for _ in range(length):
                    if src_pos < 0 or src_pos >= org_size:
                        raise ValueError("invalid LZSS back-reference")
                    result[dst_idx] = result[src_pos]
                    dst_idx += 1
                    src_pos += 1
                    if dst_idx >= org_size:
                        break

            flags >>= 1

    return bytes(result)


def parse_sizes(size_blob: bytes) -> List[int]:
    if len(size_blob) % 4 != 0:
        raise ValueError("size list length is not multiple of 4")
    count = len(size_blob) // 4
    return list(struct.unpack("<{}I".format(count), size_blob))


def decrypt_entry(blob: bytes) -> DecryptedEntry:
    if len(blob) < STNS_HEADER_STRUCT.size + 4:
        raise ValueError("entry blob too small")
    working = bytearray(blob)

    xor_stream(working, LAST_ANGOU_CODE, LAST_ANGOU_INDEX)

    header_values = STNS_HEADER_STRUCT.unpack_from(working, 0)
    md5_code = list(header_values[1 : 1 + MD5_CODE_CNT])
    lzss_data_size = header_values[-1]
    if lzss_data_size < 0:
        raise ValueError("negative LZSS payload size encountered")

    name_len_offset = STNS_HEADER_STRUCT.size
    name_len = struct.unpack_from("<I", working, name_len_offset)[0]
    name_offset = name_len_offset + 4
    name_end = name_offset + name_len
    if name_end > len(working):
        raise ValueError("name data exceeds entry size")

    name_buf = bytearray(working[name_offset:name_end])
    xor_stream(name_buf, NAME_ANGOU_CODE, NAME_ANGOU_INDEX)
    name = name_buf.decode("utf-16-le").rstrip("\x00")

    mask_w_size = c_int_mod(md5_code[MASK_W_SIZE_MD5_CODE_INDEX], MASK_W_SIZE_SURPLUS) + MASK_W_SIZE_ADD
    mask_h_size = c_int_mod(md5_code[MASK_H_SIZE_MD5_CODE_INDEX], MASK_H_SIZE_SURPLUS) + MASK_H_SIZE_ADD
    mask_buf = build_mask(md5_code, mask_w_size * mask_h_size)

    map_w_size = c_int_mod(md5_code[MAP_W_SIZE_MD5_CODE_INDEX], MAP_W_SIZE_SURPLUS) + MAP_W_SIZE_ADD
    byte_half_data_size = (lzss_data_size + 1) // 2
    dword_half_data_size = (byte_half_data_size + 3) // 4
    map_h_size = (dword_half_data_size + (map_w_size - 1)) // map_w_size
    map_total_size = map_w_size * map_h_size * 4

    first_map_offset = name_end
    second_map_offset = first_map_offset + map_total_size
    if second_map_offset + map_total_size > len(working):
        raise ValueError("entry truncated before map payloads")

    map1 = bytearray(map_total_size)
    map2 = bytearray(map_total_size)
    view = memoryview(working)

    tile_copy(map1, view[first_map_offset : first_map_offset + map_total_size], map_w_size, map_h_size, mask_buf, mask_w_size, mask_h_size, TILE_COPY_T_REP_X, TILE_COPY_T_REP_Y, 0, TILE_COPY_T_LIMIT)
    tile_copy(map1, view[second_map_offset : second_map_offset + map_total_size], map_w_size, map_h_size, mask_buf, mask_w_size, mask_h_size, TILE_COPY_T_REP_X, TILE_COPY_T_REP_Y, 1, TILE_COPY_T_LIMIT)
    tile_copy(map2, view[first_map_offset : first_map_offset + map_total_size], map_w_size, map_h_size, mask_buf, mask_w_size, mask_h_size, TILE_COPY_T_REP_X, TILE_COPY_T_REP_Y, 1, TILE_COPY_T_LIMIT)
    tile_copy(map2, view[second_map_offset : second_map_offset + map_total_size], map_w_size, map_h_size, mask_buf, mask_w_size, mask_h_size, TILE_COPY_T_REP_X, TILE_COPY_T_REP_Y, 0, TILE_COPY_T_LIMIT)

    lzss_buf = bytearray(lzss_data_size)
    lzss_buf[:byte_half_data_size] = map1[:byte_half_data_size]
    lzss_buf[byte_half_data_size:] = map2[: lzss_data_size - byte_half_data_size]

    xor_stream(lzss_buf, EASY_ANGOU_CODE, EASY_ANGOU_INDEX)
    data = lzss_unpack(bytes(lzss_buf))

    return DecryptedEntry(name=name, data=data)


def decode_pack(pack_path: Path, output_root: Path) -> List[Tuple[Path, int]]:
    pack_data = pack_path.read_bytes()
    header = to_pack_header(pack_data)

    if header.scn_data_cnt <= 0:
        raise ValueError("pack file has no scene data entries")

    indices = []
    idx_offset = header.scn_data_index_list_ofs
    for _ in range(header.scn_data_cnt):
        if idx_offset + C_INDEX_STRUCT.size > len(pack_data):
            raise ValueError("scene index table truncated")
        offset, size = C_INDEX_STRUCT.unpack_from(pack_data, idx_offset)
        indices.append((offset, size))
        idx_offset += C_INDEX_STRUCT.size

    last_offset, last_size = indices[-1]
    original_source_offset = header.scn_data_list_ofs + last_offset + last_size

    cur_offset = original_source_offset
    header_size = header.original_source_header_size
    header_blob = pack_data[cur_offset : cur_offset + header_size]
    if len(header_blob) != header_size:
        raise ValueError("original source header truncated")

    size_header = decrypt_entry(header_blob)
    sizes = parse_sizes(size_header.data)
    cur_offset += header_size

    timestamp = datetime.datetime.fromtimestamp(Path(pack_path).stat().st_mtime, tz=datetime.timezone.utc).strftime("%Y%m%d_%H%M%S")
    base_dir = output_root / f"ss_{timestamp}"

    written: List[Tuple[Path, int]] = []
    for entry_size in sizes:
        entry_blob = pack_data[cur_offset : cur_offset + entry_size]
        if len(entry_blob) != entry_size:
            raise ValueError("entry truncated before expected length")
        cur_offset += entry_size

        entry = decrypt_entry(entry_blob)
        relative_path = Path(*PureWindowsPath(entry.name).parts)
        destination = base_dir.joinpath(relative_path)
        destination.parent.mkdir(parents=True, exist_ok=True)
        destination.write_bytes(entry.data)
        written.append((destination, len(entry.data)))

    return written


def main(argv: Sequence[str] | None = None) -> None:
    args = parse_args(argv)
    pack_path: Path = args.pack
    output_root: Path = args.output.resolve()
    output_root.mkdir(parents=True, exist_ok=True)

    written = decode_pack(pack_path.resolve(), output_root)

    print(f"Decoded {len(written)} file(s):")
    for path, size in written:
        print(f"  {path} ({size} bytes)")


if __name__ == "__main__":
    main()
