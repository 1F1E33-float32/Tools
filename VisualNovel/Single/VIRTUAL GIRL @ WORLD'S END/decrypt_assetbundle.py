import argparse
import ctypes
import os
from typing import List, Sequence, Union

# fmt: off
BYTES256: Sequence[int] = (
    0x56,0x91,0xBC,0xDF,0x11,0xB3,0x6F,0xF6,0x15,0xD2,0x40,0x39,0x18,0x4F,0x0E,0x9C,
    0x05,0xB2,0x17,0xD8,0x93,0x03,0x81,0xFE,0x5F,0xC4,0x24,0xCF,0x4D,0xC5,0x45,0xBE,
    0x52,0x74,0xBD,0xAD,0x0B,0xA6,0x60,0x94,0x57,0x27,0x2D,0xE2,0x6A,0x55,0x96,0xEF,
    0x69,0x41,0xE1,0x6C,0x62,0xA5,0xF7,0x80,0xBF,0x1B,0x79,0xFB,0xCA,0x5B,0x21,0xB1,
    0x8F,0x04,0xFC,0x37,0x3F,0x0C,0x86,0x8A,0x65,0x77,0xB7,0xAA,0xFD,0x7A,0x34,0xF0,
    0x97,0xF5,0x6D,0x2C,0xD5,0x48,0x66,0x3C,0x9D,0xB0,0xD1,0xA9,0x58,0x78,0xD7,0x6E,
    0xE3,0x51,0x87,0xAC,0x63,0xD4,0xE9,0x47,0x23,0xE8,0x36,0x7D,0xE5,0xF2,0xC3,0x5C,
    0x84,0x88,0x76,0x1A,0xA4,0xC0,0xF3,0x31,0x99,0x9B,0x6B,0x2E,0x98,0xEE,0x4B,0x5A,
    0x44,0xC7,0xF8,0xC1,0xB5,0x53,0xA2,0x32,0xC9,0xBA,0x7B,0x1E,0x10,0xA3,0x00,0x01,
    0x14,0x4A,0x08,0x0D,0x46,0x95,0x8C,0xB6,0x8D,0xB8,0xFF,0x75,0x4C,0xB4,0x64,0xDE,
    0x85,0xA7,0x30,0x43,0x1F,0xDB,0x7E,0x50,0x26,0x35,0x20,0x92,0xCE,0x9A,0x9E,0xEB,
    0xF4,0x1C,0xF9,0x33,0x38,0xDD,0x29,0xF1,0x3A,0x2F,0x5E,0x73,0xD3,0xE6,0x54,0xB9,
    0x68,0xCD,0xAF,0x06,0xD9,0xD0,0x61,0x83,0x8E,0xC6,0xE7,0x7F,0xDA,0xAB,0x12,0x0F,
    0x89,0xBB,0xD6,0x3B,0xC2,0xA1,0x3D,0x72,0x70,0x19,0xCB,0xA8,0x22,0x2A,0x59,0x4E,
    0x90,0x28,0x07,0x71,0x13,0xA0,0x5D,0xCC,0x7C,0xED,0xFA,0x16,0x9F,0xEC,0x09,0x67,
    0x02,0xEA,0x25,0x82,0x3E,0x49,0xAE,0x0A,0x42,0xE0,0x8B,0x1D,0xDC,0x2B,0xE4,0xC8,
)
# fmt: on


def _to_signed32(x: int) -> int:
    x &= 0xFFFFFFFF
    return x if x < 0x80000000 else x - 0x100000000


def _jamming_int(top_index: int, table: Sequence[int]) -> int:
    i = top_index & 0xFF
    b0 = table[i]
    b1 = table[(i + 1) & 0xFF]
    b2 = table[(i + 2) & 0xFF]
    b3 = table[(i + 3) & 0xFF]
    return (b0 | (b1 << 8) | (b2 << 16) | (b3 << 24)) & 0xFFFFFFFF


def _get_item(s_bytes: bytes, index: int) -> int:
    if index < 0 or index >= 64:
        return 0
    return s_bytes[index] if index < len(s_bytes) else 0


def amber_hash_get_hashcode(s: Union[str, bytes], pattern: int = 0, table: Sequence[int] = BYTES256) -> int:
    s_bytes = s.encode("latin-1", errors="ignore") if isinstance(s, str) else bytes(s)
    L = len(s_bytes)
    if L == 0:
        return 0

    # 1) 四个种子
    A: List[int] = [0, 0, 0, 0]
    for i in range(4):
        idx = L - 1 - i
        if idx < 0:
            idx = 0
        itm = _get_item(s_bytes, idx)
        A[i] = _jamming_int(pattern + 4 * i + itm, table)

    # 2) 从右往左滚动
    t = 0  # 8位 char
    for p in range(L - 1, -1, -1):
        b = _get_item(s_bytes, p)  # p>=64 会返回 0
        t = (b ^ ((p + t) & 0xFF)) & 0xFF
        A[p & 3] = (A[p & 3] + ((b & 0xFF) << (t & 31))) & 0xFFFFFFFF

    # 3) 合并
    return _to_signed32(A[0] ^ A[1] ^ A[2] ^ A[3])


def decrypt_bytes(buf: bytearray, key_value: int) -> None:
    if not isinstance(buf, bytearray):
        buf = bytearray(buf)

    key_hi_xor = ((key_value << 32) & 0xFFFFFFFFFFFFFFFF) ^ 0xFFFFFFFF00000000
    key_sign64 = ctypes.c_int64(key_value).value & 0xFFFFFFFFFFFFFFFF
    key64 = (key_hi_xor | key_sign64) & 0xFFFFFFFFFFFFFFFF

    kbytes = key64.to_bytes(8, "little")

    mv = memoryview(buf)
    for i in range(len(mv)):
        mv[i] ^= kbytes[i & 7]

    return buf


if __name__ == "__main__":
    ap = argparse.ArgumentParser()
    ap.add_argument("file", help="input folder path")
    ap.add_argument("--pattern", type=int, default=0, help="Amber.Hash pattern (default: 0)")
    args = ap.parse_args()

    in_path = os.path.abspath(args.file)
    if not os.path.isdir(in_path):
        raise SystemExit(f"[!] Not a folder: {in_path}")

    for root, _, files in os.walk(in_path):
        folder_name = os.path.basename(root) or ""
        for fname in files:
            if "_dec" in fname:
                continue

            fpath = os.path.join(root, fname)
            if not os.path.isfile(fpath):
                continue

            base_for_hash = f"{folder_name}/{fname}"
            key = amber_hash_get_hashcode(base_for_hash, args.pattern, BYTES256)

            out_path = fpath + "_dec"

            with open(fpath, "rb") as f:
                enc = f.read()
            dec = decrypt_bytes(enc, key)

            with open(out_path, "wb") as f:
                f.write(dec)
