import os
import struct

# LZ decompression function

def LZdecompr(buff: bytes, outlen: int) -> bytes:
    uncompr = bytearray()
    iSrc = 0
    buff_len = len(buff)

    while iSrc < buff_len and len(uncompr) < outlen:
        code = buff[iSrc]
        iSrc += 1

        for bit in range(8):
            if (code >> bit) & 1:
                # literal byte
                uncompr.append(buff[iSrc])
                iSrc += 1
                if iSrc > buff_len or len(uncompr) >= outlen:
                    break
            else:
                # back-reference
                if iSrc + 1 >= buff_len:
                    break
                # low nibble +2 = count
                count = (buff[iSrc] & 0x0F) + 2
                # high nibble and next byte for position
                pos = (buff[iSrc] >> 4) | (buff[iSrc+1] << 4)
                iSrc += 2
                for _ in range(count):
                    uncompr.append(uncompr[-pos])
                if iSrc > buff_len or len(uncompr) >= outlen:
                    break

    return bytes(uncompr)

# Decode table, 256 entries

decode_table=[
    0x8B, 0xE5, 0x5D, 0xC3, 0xA1, 0xE0, 0x30, 0x44, 0x00, 0x85, 0xC0, 0x74, 0x09, 0x5F, 0x5E, 0x33, 0xC0, 0x5B, 0x8B, 0xE5, 0x5D, 0xC3, 0x8B, 0x45, 0x0C, 0x85, 0xC0, 0x75, 0x14, 0x8B, 0x55, 0xEC,
    0x83, 0xC2, 0x20, 0x52, 0x6A, 0x00, 0xE8, 0xF5, 0x28, 0x01, 0x00, 0x83, 0xC4, 0x08, 0x89, 0x45, 0x0C, 0x8B, 0x45, 0xE4, 0x6A, 0x00, 0x6A, 0x00, 0x50, 0x53, 0xFF, 0x15, 0x34, 0xB1, 0x43, 0x00,
    0x8B, 0x45, 0x10, 0x85, 0xC0, 0x74, 0x05, 0x8B, 0x4D, 0xEC, 0x89, 0x08, 0x8A, 0x45, 0xF0, 0x84, 0xC0, 0x75, 0x78, 0xA1, 0xE0, 0x30, 0x44, 0x00, 0x8B, 0x7D, 0xE8, 0x8B, 0x75, 0x0C, 0x85, 0xC0,
    0x75, 0x44, 0x8B, 0x1D, 0xD0, 0xB0, 0x43, 0x00, 0x85, 0xFF, 0x76, 0x37, 0x81, 0xFF, 0x00, 0x00, 0x04, 0x00, 0x6A, 0x00, 0x76, 0x43, 0x8B, 0x45, 0xF8, 0x8D, 0x55, 0xFC, 0x52, 0x68, 0x00, 0x00,
    0x04, 0x00, 0x56, 0x50, 0xFF, 0x15, 0x2C, 0xB1, 0x43, 0x00, 0x6A, 0x05, 0xFF, 0xD3, 0xA1, 0xE0, 0x30, 0x44, 0x00, 0x81, 0xEF, 0x00, 0x00, 0x04, 0x00, 0x81, 0xC6, 0x00, 0x00, 0x04, 0x00, 0x85,
    0xC0, 0x74, 0xC5, 0x8B, 0x5D, 0xF8, 0x53, 0xE8, 0xF4, 0xFB, 0xFF, 0xFF, 0x8B, 0x45, 0x0C, 0x83, 0xC4, 0x04, 0x5F, 0x5E, 0x5B, 0x8B, 0xE5, 0x5D, 0xC3, 0x8B, 0x55, 0xF8, 0x8D, 0x4D, 0xFC, 0x51,
    0x57, 0x56, 0x52, 0xFF, 0x15, 0x2C, 0xB1, 0x43, 0x00, 0xEB, 0xD8, 0x8B, 0x45, 0xE8, 0x83, 0xC0, 0x20, 0x50, 0x6A, 0x00, 0xE8, 0x47, 0x28, 0x01, 0x00, 0x8B, 0x7D, 0xE8, 0x89, 0x45, 0xF4, 0x8B,
    0xF0, 0xA1, 0xE0, 0x30, 0x44, 0x00, 0x83, 0xC4, 0x08, 0x85, 0xC0, 0x75, 0x56, 0x8B, 0x1D, 0xD0, 0xB0, 0x43, 0x00, 0x85, 0xFF, 0x76, 0x49, 0x81, 0xFF, 0x00, 0x00, 0x04, 0x00, 0x6A, 0x00, 0x76,
]

# Helper to read a little-endian unsigned 32-bit integer

def read_u32(data: bytes, offset: int) -> int:
    return struct.unpack_from('<I', data, offset)[0]

# Primary decode routine, operating on raw chunk bytes

def decode_chunk(chunk: bytes) -> bytes:
    # deoff at offset 0x20, size at offset 0x28
    deoff = read_u32(chunk, 0x20)
    size = read_u32(chunk, 0x28)

    # prefix and XOR buffer
    prefix = chunk[:deoff]
    xord = bytearray(size)
    for i in range(size):
        xord[i] = chunk[deoff + i] ^ decode_table[i & 0xFF]

    # decompress remainder
    # first 4 bytes of xord are unused header, next 4 bytes is output length
    outlen = struct.unpack_from('<I', xord, 4)[0]
    compressed_data = bytes(xord[8:])
    uncompr = LZdecompr(compressed_data, outlen)

    return prefix + xord[:8] + uncompr

# Main processing function

def main():
    index_file = r"D:\Reverse\_GalGame\Re_Call\Eden Project\game tools\X-moe-master\Unpacker\RealLive\rldev\bin\SEEN.TXT"
    out_dir = 'seen'
    entry_count = 10000

    # Read all index entries (8 bytes each)
    with open(index_file, 'rb') as f:
        idx_data = f.read(entry_count * 8)

    if not os.path.exists(out_dir):
        os.makedirs(out_dir)

    # Iterate entries
    for i in range(entry_count):
        off, size = struct.unpack_from('<II', idx_data, i * 8)
        if off == 0:
            continue

        with open(index_file, 'rb') as f:
            f.seek(off)
            chunk = f.read(size)

        decoded = decode_chunk(chunk)
        out_path = os.path.join(out_dir, f'seen{i:04d}.txt')
        with open(out_path, 'wb') as out_f:
            out_f.write(decoded)

        print(f"{i:04d} Success")

    print('Success')

if __name__ == '__main__':
    main()